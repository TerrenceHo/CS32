1)
Data structure description:  Map whose values map to a linkedlist.  The Map's key are custom Point classes that don't store x,y value, each corresponding to a unique point on the field.  Each linkedlist is a doubly linkedlist with a dummy node, allowing smooth insertion and deletion. Each node points to one class object, and also contains a bool that tracks whether the object acted this tick already. A location (0,0) on the field corresponds to a Point(0,0) on the map, and etc.

StudentWorld descriptions

int StudentWorld::init()
	Get filenames, and store the names
	For each different ant file, make a new compiler and compile the .bug file
	Initialize data structure of a Map with linkedlists.  For each point in the map, add a grasshopper, pebble, poison, pool, or anthill as necessary.  Ech anthill is passed in a corresponding compiler object

int StudentWorld::move()
	update tick count
	for each point on the map, access each node.  Within each node, access the Actor Object and call doSomething(). Set the node's acted bool to true, signifying it did something already.
		if this actor moved during it's do something, insert a new node at the corresponding location and delete the current node.  The object itself is not deleted, simply that the node has changed places to match the actor's location
	Go through all Linkedlists and nodes and set their acted status to false.  Allows them to act next tick
	Delete all dead objects by querying their isDead()
	setDisplayText()
	if it has passed 2000 ticks, then either choose a winner, or it there is a tie, no winner.  End simulation

void StudentWorld::cleanup()
	Go through every point in the map, and at each point, delete the Actor pointer then the node.  lastly, delete the dummy node from the map.

StudentWorld::~StudentWorld()
	Does nothing.  Is virtual because destructors of derived class must be virtual

void StudentWorld::InsertNode(Actor * actor, int j, int i)
	Given an Actor Object, (x,y) coordinate, and acted status, add a node at the (x,y) coordinate and set the value of node to actor object.

void StudentWorld::eraseNode(Actor * actor, int j, int i)
	Given a pointer to actor object and (x,y) coordinate find the node that contains the actor object at (x,y) and unhook it from the linkedlist.  Delete the actor object then delete the node

void StudentWorld::removeNode(int j, int i, int num)
	Given a location and number of the node of the target node in the linkedlist, delete that node's object and the node itself.

int StudentWorld::numActors(int j, int i)
	Given a location on the map, return how many nodes are in the linkedlist at that point

Actor * StudentWorld::accessNodes(int j, int i, int target)
	Given a location and number of the node in the linkedlist you want to access, access the node and return the pointer to the object.

void StudentWorld:: setDisplayText()
	Format the text according to how many ant programs there are, the tick count, and the winning ant.  Displays name and number of ants generated as well.  Uses stringstreams

void StudentWorld:: updateTickCount()
	increase tick count

int StudentWorld:: getCurrentTicks()
	return current ticks

bool StudentWorld::canMoveTo(int x, int y)
	Given a location, check to see if the location contains a pebble and returns whether or not an actor can move there

Actor* StudentWorld:: getEdibleAt(int x, int y)
	Returns a pointer to a Food object at (x,y) if possible, otherwise return nullptr

Actor* StudentWorld:: getPheromone(int x, int y, int colony)
	Returns a pointer to a Pheromone object at (x,y) if possible and it's colony is the same as the passed in colony number, otherwise return nullptr

bool StudentWorld::isEnemyAt(int x, int y, int colony)
	If there is an enemy at a location, return true, otherwise false.  Calls the function isEnemy().

bool StudentWorld::isDangerAt(int x, int y, int colony)
	Returns true if there is any danger at all at the indicated location, by calling isDangerous().  returns false otherwise.

bool StudentWorld:: isAntHillAt(int x, int y, int colony)
	Returns true if colony number matches the anthill's colony at the location, otherwise return false.

void StudentWorld::increaseScore(int colony)
	increase the number of ants produced by an anthill


--------------------------------------------------------
Actor Descriptions

Actor(StudentWorld* world, int startX, int startY, Direction startDir, int imageID, int depth)
	instantiates a GraphWorld object, that passes in startX, startY, direction, imageID, depth.  Also sets Actor to alive and holds onto a StudentWorld pointer

virtual void doSomething() = 0
	This function does nothing, contrary to the name.  This function is virtual because it is reused by many derived classes when called doSomething.  This is a pure virtual function because Actor is a abstract base class that shouldn't be called into existance by itself anyway.  This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

bool isAlive() const
	returns if an Actor is alive or not. This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

void setDead()
	sets an actor to dead.  This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

virtual bool blocksMovement() const
	Returns if this actor blocks movement.  Is virtual because Pebble redefines this function to return true, while all other actors return false. This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

virtual void getBitten(int amt)
	Returns without doing anything for most actors.  For insects, it is redefined to match their specific instructions that are executed when they are bit.  Called by another actor when it bits an actor, and although not all actors can be bitten, in some cases getBitten() is called on an Actor pointer, which is why it is placed in this class

virtual void getPoisoned()
	Returns without doing anything for most actors.  For insects, it is redefined to match their specific instructions that are executed when they are poisoned.  Called by poison when it poisons the actor, and in some cases getPoisoned() is called on an Actor pointer, which is why it is placed in this class

virtual void getStunned()
	Returns without doing anything for most actors.  For insects, it is redifined to match their specific instructions that are executed when they are stunned.  Called by pool of water when it stuns an actor, and in some cases getStunned() is called on an Actor pointer, which is why it is placed in this class

virtual bool isEdible() const
	Returns false except for food actors, which can be bitten.  It is virtual to allow food objects to be differentiated. This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

virtual bool isPheromone(int colony) const
	Returns if an actor is a Pheromone that matches the colony.  Returns false except for Pheromones, which check if the colony matches with their colony.  This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

virtual bool isEnemy(int colony) const
	Returns if antor is enemy is an enemy to the ant.  This function is virtual because it is redefined multiple times, returning false for most actors, true for grasshoppers, and ants if their colonies do match up.  This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

virtual bool isDangerous(int colony) const
	Returns if an actor is dangerous to an ant.  This function is virtual because multiple actors have different return values when called. This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

virtual bool isAntHill(int colony) const
	Returns if an actor is an anthill of the same colony as an ant.  This function is virtual because most actors return false, except maybe for anthills. This is a function called by StudentWorld, who only has access to Actor pointers, so this function exists in the Actor class.

StudentWorld* getWorld() const
	Returns a pointer to the StudentWorld.  Used by all actors, so placed in Actor class.

void getCoordinates(Direction dir, int &x, int &y)
	Set x and y to the coordinates in front of an actor, based on the actor's direction.  ie if an actor is located at (0,0) and its direction is up, it x is equal to 0 and y = 1.  

-----------------------------------------------------------------------------------------
Pebble Implementation

Pebble(StudentWorld* world, int startX, int startY)
	Initializes Pebble object.  Also initializes an Actor object.
virtual void doSomething()
	Does absolutely nothing. Necessary because Actor's doSomething() include a pure virtual function

virtual bool blocksMovement() const
	Returns true, since pebbles block movement.  Redefines a Actor::blocksMovement(), which always returns false.

-----------------------------------------------------------------------------------------
EnergyHolder Implementation

EnergyHolder(StudentWorld* world, int startX, int startY, Direction startDir, int energy, int imageID, int depth)
	Instantiates an Actor object, since EnergyHolder is derived from Actor.  Also initializes initial energy of EnergyHolder objects.

virtual void doSomething()
	Does nothing, but satisfies the pure virtual function requirement

int getEnergy() const
	Returns the energy of the energyholder.  Not virtual, because it acts the same for all EnergyHolders.  Is declared in EnergyHolder so all following classes inherit it.

void updateEnergy(int amt)
	Updates the energy of an EnergyHolder by amt.  Could be positive of negative.  If energy drops below zero, the Actor is set as dead.  Not virtual because functionality is never overwritten, but can be inherited by derived classes

void addFood(int amt)
	Adds a Food object to the location of the actor that called it.  If there is already a food object, then it adds amt food to the Food object.  Not virtual because it is never redefined.

int pickupFood(int amt)
	This function is used by ants only, but it allows them to pick up an amt of food.  If the food object there has less than amt food, it takes what is left and the food object is set as dead.  Because both insects (which call this function) and Food are EnergyHolders, then it makes sense to put it here.

virtual bool becomesFoodUponDeath() const
	Returns whether or not the actor becomes Food on death.  Is virtual because some only insects become food, yet other EnergyHolders don't become Food.

void addPheromonoe(int colony)
	Like addFood(int amt), this adds a Phermone to the location.  If there is a Phermome already at the location, then that Phermone simply gains strength.  Because both insects (which call this function) and Pheromone are EnergyHolders, then it makes sense to put it here.

-----------------------------------------------------------------------------------------
Food Implementation

Food(StudentWorld* world, int startX, int startY, int energy)
	Instantiates a Food object and the EnergyHolder object it is derived from.

virtual void doSomething()
	Food does absolutely nothing.  But necessary because Actor's do something was a pure virtual function.

virtual bool isEdible() const
	Food objects are edible by other insects, so this function returns true.  Is virtual because it was redefined from Actor::isEdible(), which returned false.  Without this, Food would not be edible

-----------------------------------------------------------------------------------------
Anthill Implementation

AntHill(StudentWorld* world, int startX, int startY, int colony, Compiler* program)
	Instantiates an Anthill object and the EnergyHolder object it is derived from.  Also stores it's colony number and a compiler object that all ants use to driver their directions.

virtual void doSomething()
	Anthills lose one energy per tick.  If it has 0 or less energy, set it as dead.
	Every tick, it eats up to 10000 food, and if it does eat, it returns 
	if it has at least 2000 energy, it loses 1500 energy and dynamically creates an Ant object, that originates from the colony. Is necessary because Actor::doSomething was a pure virtual function.

virtual bool isAntHill(int colony) const
	returns true if the colony passed in matches with it's internal colony, else false.  Redefines Actor::isAntHill(int colony), which previous returned false always.  WIthout this, ants could not tell if they had reached their colony again.

-----------------------------------------------------------------------------------------
Pheromone Implementation

Pheromone(StudentWorld* world, int startX, int startY, int colony)
	Instantiates a Pheromone object as well as the EnergyHolder object it is derived from.  Also internally stores a colony number.

virtual void doSomething()
	Pheromone objects lose one energy per tick.  If it has 0 or less energy, set it as dead.  Is necessary because Actor::doSomething was a pure virtual function.

virtual bool isPheromone(int colony) const
	Returns true if colony number matches with internal colony, else false.  Is virtual because it redefines Actor::isPheromone(int colony), which previously always returned false.

-----------------------------------------------------------------------------------------
TriggerableActor Implementation

TriggerableActor(StudentWorld* world, int x, int y, int imageID)
	Instantiates a TriggerableActor Object, as well as the Actor object it is derived from.

virtual bool isDangerous(int colony) const
	Always returns true, because all TriggerableActors are dangerous in some way.  Is virtual because it redefines Actor::isDangerous(int colony).

virtual void doSomething()
	Does nothing, but satisfies the pure virtual function requirement

-----------------------------------------------------------------------------------------
WaterPool Implementaion

WaterPool(StudentWorld* world, int x, int y)
	Instantiates a WaterPool object, as well as the TriggerableActor object it is derived from.

virtual void doSomething()
	Attemps to stun an insect for 2 turns.  Is necessary because Actor::doSomething was a pure virtual function.

-----------------------------------------------------------------------------------------
Poison Implementation

Poison(StudentWorld* world, int x, int y)
	Instantiates a Poison object, as well as the TriggerableActor object it is derived from.

virtual void doSomething()
	Attemps to poison an insect and deal some damage.  Is necessary because Actor::doSomething was a pure virtual function.

-----------------------------------------------------------------------------------------
Insect Implementation

Insect(StudentWorld* world, int startX, int startY, int energy, Direction dir, int imageID)
	Instantiates an Insect object, as well as the EnergyHolder object it is derived from.  Also stores its sleeping time, whether it can be slept, and whether it can be stunned.

virtual void doSomething()
	Does nothing, but satisfies the pure virtual function requirement

virtual void getBitten(int amt)
	Causes insect to take amt damage.  If the actor's health drops below 0, then it is set as dead. Is virtual because this function can be overwritten by Adult Grasshopper, which adds extra functionality.

virtual void getPoisoned()
	Causes insect to take 150 damage.  If the actor's health drops below 0, then it is set as dead.  Is virtual because this function can be overwritten by Adult Grasshopper, which adds different functionality.

virtual void getStunned()
	Causes insect to sleep for 2 ticks.  It also makes it unable to be stunned until the insect moves off the location that is stunning it.  Virtual because AdultGrasshopper overrides this functionality later.

virtual bool isEnemy(int colony)
	Returns true.  However, it is virtual because ant may redefine it later on.

virtual bool isDangerous(int colony) const
	Returns true.  However, it is virtual because ant may redefine it later on.

virtual bool becomesFoodUponDeath() const
	All insects become food on death.  Redefining EnergyHolder::becomesFoodOnDeath()

bool getAsleep() const
	Return if insect is asleep.  Held in insect class since it holds the sleeping variables.

void setAsleep(bool asleep)
	Either sets an insect to asleep or awake depending on bool asleep.  Held in insect class since it holds the sleeping variables.

int getSleepCount() const
	Returns how many turns it has left to sleep. Held in insect class since it holds the sleeping variables.

void addSleepCount(int amt)
	Adds amt to the sleep count.  Can be positive or negative. Held in insect class since it holds the sleeping variables.

void setStunnedLocation()
	Returns where it was last stunned.  Used so that a pool does not continuously stun an insect.

void getStunnedLocation(int &x, int &y)
	sets x and y to where the insect was last stunned to their respective coordinates.  Used so that a pool does not continuously stun an insect.

void setStunStatus(bool stun)
	Change if an insect can be stunned or not.  Used so that a pool does not continuously stun an insect.

bool getStunStatus()
	Return if an insect is stunned or not. Used so that a pool does not continuously stun an insect.

-----------------------------------------------------------------------------------------
Ant Implementation

Ant(StudentWorld* world, int startX, int startY, int colony, Compiler* program, int imageID)
	Instantiates an Ant object, as well as the Insect object it was derived from.  Also stores colony number, compiler program, instruction counter, random value counter, whether it was bitten, whether it was blocked, and the amount of food it holds.

virtual void doSomething()
	Loses 1 energy.  If it's health drops below zero, it dies and food replaces it.
	if it is asleep, decrease the time it has left to asleep and return
	Call the interpreter.  If the interpreter returns with an error, the ant dies.
	Check if it can be stunned from WaterPool. 

bool interpreter()
	Using Command from Compiler.h, check the commands and do something to the ant.  If the command is goto, sets instruction counter to the number goto points to.  If the commands is if, then evaluate the condition and if it is true, do the goto.  Else the ant does one thing based on these commands.
		emitPheromone,
		faceRandomDirection,
		rotateClockwise,
		rotateCounterClockwise,
		moveForward,
		bite,
		pickupFood,
		dropFood,
		eatFood,
		generateRandomNumber
	Then it returns true after doing one of these things. 

bool evaluateCondition(std::string condition)
	Evaluates if certain conditions are true based on the compiler. Called in interpreter. Evaulates these conditions:
		i_smell_danger_in_front_of_me,
		i_smell_pheromone_in_front_of_me,
		i_was_bit,					
		i_am_carrying_food,			
		i_am_hungry,				
		i_am_standing_on_my_anthill,
		i_am_standing_on_food,		
		i_am_standing_with_an_enemy,
		i_was_blocked_from_moving,	
		last_random_number_was_zero		

virtual bool isEnemy(int colony) const
	Returns true if the colony numbers are not the same, if it is the same, return false.  It is virtual because it redefines previously defined isEnemy(int colony) functions.  Used by ants to tell the difference between friendly and enemy ants.

virtual bool isDangerous(int colony) const
	Returns true if the colony numbers are not the same, if it is the same, return false.  It is virtual because it redefines previously defined isDangerous(int colony) functions.  Used by ants to tell the difference between friendly and enemy ants, as well as detecting poison and pool and grasshoppers.

void bite()
	Bites another insect at it's current location.  

-----------------------------------------------------------------------------------------
Grasshopper Implementation

Grasshopper(StudentWorld* world, int startX, int startY, int energy, int imageID)
	Instantiates a Grasshopper object, as well as the Insect object it is derived from. Steps steps to a random value between 2,10

virtual void doSomething()
	Does nothing, but satisfies the pure virtual function requirement

virtual bool isEnemy(int colony) const
	returns true, because grasshoppers are always enemies of ants.

int getSteps() const
	Return the number of steps Grasshopper has yet to take.

void adjustStepCount(int amt)
	adjusts step count based on amt.  Can be positive or negative.  

void setStepCount(int amt)
	Sets the step count to amt.

-----------------------------------------------------------------------------------------
BabyGrasshopper Implementation

BabyGrasshopper(StudentWorld* world, int startX, int startY)
	Instantiates a BabyGrasshopper object, as well as the Grasshopper object it is derived from. 

virtual void doSomething()
	It's energy decreases by one every tick
	if it is asleep, decrease the time it has left to asleep and return
	If it's energy is above 1600, delete BabyGrasshopper and create an AdultGrasshopper.
	Attemps to eat 200 units of food.  If it does so, there is a 50% chance of it sleeping.
	Try to move in it's direction.  If it can't, then it will not move, choose a new direction and new number of steps to move in that direction. 
	Check if it can be stunned
	Sleep for two ticks.
	This virtual function overwrites a previous doSomething() function

virtual void getBitten(int amt)
	Causes a grasshopper to get bitten, it takes amt damage.  If it dies, set it to dead.

-----------------------------------------------------------------------------------------
AdultGrasshopper Implementation

AdultGrasshopper(StudentWorld* world, int startX, int startY)
	Instantiates a AdultGrasshopper object, as well as the Grasshopper object it is derived from.

virtual void doSomething()
	It's energy decreases by one every tick
	if it is asleep, decrease the time it has left to asleep and return
	there is a 1/3 chance the AdultGrasshopper will try to bite back.
	There is a 1/3 chance it will try to jump to a random space in a 10 space radius of itself.
	Attemps to eat 200 units of food.  If it does so, there is a 50% chance of it sleeping.
	Try to move in it's direction.  If it can't, then it will not move, choose a new direction and new number of steps to move in that direction. 
	Sleep for two ticks.
	This virtual function overwrites a previous doSomething() function

virtual void getBitten(int amt)
	Causes a grasshopper to get bitten, it takes amt damage.  If it dies, set it to dead.
	There is a 50% chance it will attempt to bite back at an insect of the same square if it was bitten.

virtual void getPoisoned()
	AdultGrasshopper cannot get poisoned, so it returns.  Virtual to overwrite the fact that insects can get poisoned.

virtual void getStunned()
	AdultGrasshopper cannot get stunned, so it returns. Virtual to overwrite the fact that insects can get stunned.




2) This may or may not be a bug, but my ants seem to generate more ants on average per run than the sample does, yet I can't pin down a reason, so it might be down to statistical bias.  Other than that I believe I implemented every functionality.

3) In the design, it did not say that newly allocated objects during a doSomething() call could be activated or not, so I simply allowed new objects to be called.  I also wasn't sure if grasshoppers were supposed to be poisoned 3 times in a row since they also sleep in the poison, so I left that feature in.

4) 
StudentWorld
	Mainly that the objects on screen move and new objects are allocated and deallocated when they are created or deleted.  I made sure that a Map of Points (a class I made) was viable and had no overlap in value (so that each coordinate was a unique value). 

Base classes were not tested directly but by correlation of the following classes working, the base classes should be correct. 

Pebble
	I made sure that no other object or actor could move onto a square with a pebble on it.  Other than that there was not much to test, because it didn't do anything.  The basic field was enough to confirm that pebbles were able to block movement.

Food
	While playing with the simulation I made sure to watch out for when food was allocated and deallocated when it was destroyed.  I created a new field in which I forced the food to be eaten and watched it be destroyed by moving grasshoppers.  Once the grasshoppers died out due to starvation, I watched the food be created by the dead grasshoppers/ants.

Anthill
	I did not create a new Field explicitly to test this class, but by virtue of watching ants and anthill interact and occasionally create new ants, I can confirm that anthills works correctly as I implemented it.  During my tests, I discovered that I could not delete a compiler object that was attached to the anthill, lest the program crash when ants tried to call their instructions.  

Pheromone
	I created instructions for ants to drop phermones as they travelled in a .bug file.  Then when they encountered those Pheromone again, they would turn to the side, while continuing to drop Pheromone (which made an esay trail to follow).  As such, it confirmed that they were able to both drop and smell their Pheromone they produced.  

WaterPool
	Using the pause and click per tick feature of the program, I was able to count the turns a grasshopper and ant were asleep when they hit a waterpool, which was enough to confirm to me that waterpools were working correctly.

Poison
	I set various breakpoints that allowed me to check when an ant or grasshopper walked through poison and see their health decrease.  Additionally, I checked when grasshoppers or ants died from poison by pausing and clicking through each tick.

Ant
	I created new .bug files and instructions to test each possible if condition, goto, and other command statements, creating new field files if necessary to speed up each test.  I made sure that ants could drop food into the anthill to grow more ants.  I also tested functions like whether ants died over time, whether it would be stunned or poisoned, and whether pools would double stun ants.  I tested the ant's bite by creating a new field and forcing it to bite a grasshopper.  I tested the various turning functions, whether it could emit Pheromone, eat food, pick up food, whether it could generate a random value.


BabyGrasshopper
	I made sure that grasshoppers died after 500 units and generated food by not allowing them to gain health through eating.  Additionally, I confirmed that they spawned AdultGrasshoppers by simple observation.  This also confirmed that grasshoppers were eating food. I made sure that BabyGrasshopper slept every two ticks but pausing and clicking through each tick.  I also tested functions like whether grasshoppers died over time, whether it would be stunned or poisoned, and whether pools would double stun grasshopppers.

AdultGrasshopper
	AdultGrasshopper was pretty similiar to BabyGrasshopper's testing, except I set breakpoints each time it attempted to bite something, which notified me if the bite was working corrently.  Additionally, it's not affected by poison or water pools, which is easily confirmed by pausing and playing through tick by tick.  Lastly, AdultGrahoppers jump in a circle of radius, so it was rather easy to test: simply see if it jumps a short distance every once in a while.










